# DEMO STEPS

## Setup and starting point

Let's review the setup and starting point. I'm using React Router v7 here, then tailwind for CSS and a Prisma Postgres database, using Prisma as the ORM.

## All features

Be in fullscreen version in deployed app.

Show the app. We have a list of notes, a form to add new notes, and a way to navigate. View notes, get random note, add new link, create + validate (funny note), delete, favorite.

## Boilerplate

Go to split view.

We recognize the boilerplate from the slides. We have a `vite.config.ts`, react-router.config.js` file, a `tsconfig.json` file. Prisma stuff and public folder. Eslint and prettier are also set up.

An `app` folder, and i revealed the entry.server and entry.client files. Here are components and the routes.

## Routing: /routes, routes.ts

Let's start with routes.ts. Special file containing route config. Showcase this. Here code based routing defining my RR Route Modules, and their corresponding file. You can also use file based routing, but in the transition from remix to react router the team now recommend code based. routing is more flexible, but you do have the ability to mess it up by accident. A bit more to maintain. But actually the file based system was not great to its good to have this option. Route modules are code split so we can lazily load js as we navigate to new routes for better performance.

The .react-router folder here is autogenerated to provide type safety which is really nice. It provides type safe route module props, like loaderData, actionData, and params. This is a great feature of React Router v7.

## RR Route Modules: root.tsx

Start with root.tsx. This is the root route module. It has a special Layout export' returning the root document with the metadata and links that are collected from link functions and meta functions for route modules, and inserted into the head. It's then returning the children of the layout, which is the default export, App.

## Layouts: root.tsx

App has a Outlet component, the outlet is for defining this routes children routes, using nested layouts here. This allows us to build complex UIs. And React Router can fetch data for all nested routes in parallel.

## Error boundaries: root.tsx

Error boundaries for each route module using useRouteError. Here we catch any error that might occur. We can show a custom error message here. We can also use the error hook to get the error and show it in the UI.

## UI: home.tsx

Lets look at home.tsx. Default/index child of the root.tsx. Showcase in app the page. Use the web! Central part of React Router. React Router feels familiar to old school devs. Less react-y. Learning the web when learning React Router. This is a RR Route Module for the index page. It's using the React Router Link component to provide client side navigation.

It's also defining metadata to be collected for the head with this meta function. Can see it in the title "Notes".

## CSS: home.tsx

Home.tsx. Here I'm using tailwind, but React Router also has this feature called links. This is a way to solve performance issues with CSS. You can use links to load CSS only when needed. It defined a linkFunction that returns a link to the CSS file. Not using it here.

## Data fetching: notes.tsx

Lets move to the rest of the files. Jokes.tsx is a relative route. Go to notes in demo. Another route module for the url /notes. LIVE CODE LOADER. Fetching data from the database - a list of notes. It's using Prisma to interact with the database. It's using the loader to fetch the data and return it to the component using the loaderData prop and type safe Route.ComponentProps. Importing autogenerated types from .react router to get type safe loader. We don't need useEffect fetching, kind of like getServerSideProps in Next.js. There is also a clientLoader option for doing client-side fetching, but we are not using it here. This is a server-side loader that fetches the data from the database and returns it to the component.

It's defining lots of UI from this default component. A header, a sidebar with notes and Links, and mapping notes to link with prefetch. If prefetched, we don't see this indicator. Using the href utility to get type safety!

Further down there is a Outlet component and a footer, the outlet is for defining this routes children routes, using nested layouts here again.

## Errors: notes/random-note.tsx

The random-note.tsx is the index route is the default child of the notes route, and is rendered in the outlet on the route. It's using a loader to fetch a random note. Throws a 404 if no note is found.

Here we catch the error that might occur when posting a new note to the db. We can show a custom error message here. We can also use the error hook to get the error and show it in the UI. Here catching a 404 error to display a custom message with a link to the notes page. Using the href utility to get type safety! This was actually a big problem in the past with React Router, no type safety for links, but now we have it with the href utility.

## Mutations: notes/new.tsx

Relative route. Lets move to the notes.new.tsx route module. Default export has a form, capital letter. This is similar to our example from the slides. React Router Form component will provide extra features on top of default form component, such as client side nav avoiding full page reload.

LIVE CODE ERROR BOUNDARY. Catch the not implemented error and show a custom error message. Avoiding full app error.

There is a method post on this, which will call the route for the route module with its action. LIVE CODE ACTION. The action validates using zod and returns errors if invalid inside a badRequest wrapper. Customizable. Then it redirects. Show console of network tab to show the post and get requests. GET data note.new. POST data note.new with location in the equest. New GET for revalidation. Again, server-side mutation that updates the database, but there is a client side equivalent clientAction if we were not working with the server side.

We don't need api routes to talk to our server from the client. Route module is it's own API route talking to itself. Using web standards like fetch and form submission.

## Revalidation: notes/new.tsx

Data is automatically revalidates. No fuss with adding items to lists. It's always the same. No manual revalidation. It's always in sync with the server. We can push or filter lists client side.

Show network tab loading and revalidating.

## RRM for single note: notes/detail.tsx

Lets move to a more complex route module with lots of features.

Go to detail.tsx. This is a dynamic route with params. Show it in the app. It's a route module for a single note. It's using the loader to fetch the data for the note with the id from the database. It's using the loaderData prop to pass the data to the component, and throw a 404 if no note is found.

It's also using the useRouteError hook to catch any errors that might occur when fetching the data. It's using the error hook to get the error and show it in the UI and handle 404 errors differently.

JokeDisplay can delete a note, but this is now a relative URL using a action="/destroy". Using a form as well which is unfamiliar for React devs who usually just do button onClicks. This is a relative URL that will call the route module with the action destroy. Defined with file based routing. It's using the action to delete the note from the database, and redirect. Web standard stuff that at least for me is very unfamiliar as a React SPA dev originally. Delete checks for the intent to be expected. This can be used to handle multiple actions in the same route module. Then deletes from the db and redirects.

It can also be favorited. Maybe a bit weird to see a form for this. This triggers the relative URL action="/". This is a relative URL that will call the route module with the action favorite. Here we use a fetcher Form because we are not navigating anywhere and we don't want to trigger a new push to the router.

## Browser framework

The app has some, realistic added delay and that makes it not feel so good. And until we didn't actually use that much of the browser framework, only Form and Links and prefetching etc. Does this feel like React? We are able to create all this without any React-stuff. Amazing right?

Let's switch to another version of the app that has some UI enhancements using more of the browser framework of React Router.

### Loading UI: home.tsx

LIVE CODE: In the home.tsx, we will use a React Router specific hook called useNavigation. It will give you the current state of the navigation, and provide i.e whether the router is navigating, which we use here to mark the page as pending with css or text. This hook adds on top of our base case HTML web standard document with additional client-side, js enhanced features. This is React Router's way to do progressive enhancement.

### Loading UI: notes.tsx

LIVE CODE: We will again use the useNavigation hook to show a loading state when navigating to the notes page, here with CSS and a pulsing animation. However, to avoid running it during our creating of new note, we need to add a check for the pathname.

As someone coming from Next.js, this feels weird because you never get global behavior to like that unless you specifically create it yourself with a context.

We will also use the prop callbacks from NavLink to render and style the link based on its state, here isPending and isActive. Browser framework is used to enhance the UI with loading states and active states.

### Pending UI + Optimistic UI: notes/detail.tsx

LIVE CODE: Delete is enhanced with a disabled button again when the navigation is not idle and is on the intent "delete".

For the favorite, we can get the state of this fetcher form locally and do another optimistic update. Fetcher is local scoped to the component.

### Optimistic UI: notes/new.tsx

LIVE CODE: It's doing optimistic UI by returning a view of a JokeDisplay if the validation succeeds. This is a client side update that will show the note in the list before the server has responded.

## Progressive enhancement turn off JS

Go to fullscreen app.

Turn off JS and see that the app still works. Web fundamentals in play to navigate, submit forms. Just lacking the client side enhancement of prefetching and client side navigation. And no client side loading state. And optimistic updates. Can even favorite because it's a form.

Can return errors from the form and delete notes. But we don't get client side pending state or optimistic updates. Thats all a progressive enhancement of this base case web standard application.

## Conclusion

We still didn't use any useState or useEffect here. But we can of course add it to our relevant components without any problem in the future. You know how to do that! React Router solves problems with RRM and additional hooks. Can integrate any libs like normal for more react stuff. Feels native to web.
