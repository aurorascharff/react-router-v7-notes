# DEMO STEPS

## Setup and starting point

In fullscreen: Let's review the setup and starting point. I'm using React Router v7 here, then tailwind for CSS and a Prisma Postgres database, using Prisma as the ORM. Half completed notes app. Let's review what's here so far and finish the implementation.

## Boilerplate

Go to split view.

We recognize the boilerplate from the slides. We have a `vite.config.ts`, react-router.config.js` file, a `tsconfig.json` file. Prisma stuff and public folder. Eslint and prettier are also set up.

An `app` folder, and i revealed the entry.server and entry.client files. Here are components and the routes.

## Routing: /routes, routes.ts

Let's start with routes.ts. Special file containing route config. Showcase this. Here code based routing defining my RR Route Modules, and their corresponding file. You can also use file based routing, but in the transition from remix to react router the team now recommend code based. Code based routing is more flexible, but you do have the ability to mess it up by accident. A bit more to maintain. But actually the file based system was not great to its good to have this option. Route modules are code split so we can lazily load js as we navigate to new routes for better performance.

The .react-router folder here is autogenerated to provide type safety which is really nice. It provides type safe route module props, like loaderData, actionData, and params.

## RR Route Modules: root.tsx

Start with root.tsx. This is the root route module. It has a special Layout export returning the root document with the metadata and links that are collected from link functions and meta functions for route modules, and inserted into the head. It's then returning the children of the layout, which is the default export, App.

## Layouts: root.tsx

App has a Outlet component, the outlet is for defining this routes children routes, using nested layouts here. Defined as a layout in routes.ts. This allows us to build complex UIs. And React Router can fetch data for all nested routes in parallel. A parent route without a path, used exclusively for grouping child routes inside a specific layout.

## Error boundaries: root.tsx

Error boundaries for each route module using useRouteError. Here we catch any error that might occur. We can show a custom error message here. We can also use the error hook to get the error and show it in the UI.

## UI: home.tsx

Lets look at home.tsx. Default/index child of the root.tsx. Showcase in app the page. Use the web! Central part of React Router. React Router feels familiar to old school devs. Less react-y. Learning the web when learning React Router. This is a RR Route Module for the index page. It's using the React Router Link component to provide client side navigation. In the settings, this has been pre-rendered since it's static.

It's also defining metadata to be collected for the head with this meta function. Can see it in the title "Notes".

## CSS: home.tsx

Home.tsx. Here I'm using tailwind, but React Router also has this feature called links. This is a way to solve performance issues with CSS. You can use links to load CSS only when needed. It defined a linkFunction that returns a link to the CSS file. Not using it here.

Actually have an error here because I'm using the href utility to get type safety! This is recently added and was actually a big problem in the past with React Router, no type safety for links, but now we have it with the href utility. It's telling me that the "notes" route is not defined in the routes.ts file. So I need to add it there.

## Data fetching: notes/sidebar.tsx

Let's add another route. Go to config and connect a layout to a file, and also provide an index route random-note.tsx. Another route module for the url /notes. LIVE CODE ADD ROUTE.

It's defining lots of UI from this default component. A header, a sidebar with notes and Links, and mapping notes to link with prefetch.

LIVE CODE LOADER. Fetching data from the database - a list of notes. It's using Prisma to interact with the database. It's using the loader to fetch the data and return it to the component using the loaderData prop and type safe Route.ComponentProps. Crossing server boundary, no api route lack of types. Importing autogenerated types from .react router to get type safe loader. We don't need useEffect fetching, kind of like getServerSideProps in Next.js. There is also a clientLoader option for doing client-side fetching, but we are not using it here. This is a server-side loader that fetches the data from the database and returns it to the component.

Showcase React router devtools, community extension for React Router. It shows the current route, the current location, and the current state of the router. It also shows the current data for the route modules.

Further down there is a Outlet component and a footer, the outlet is for defining this routes children routes, using nested layouts here again.

## Errors: notes/random-note.tsx

It's rendered in the outlet on the route. It's using a loader to fetch a random note. Throws a 404 if no note is found.

Here we catch the error that might occur when posting a new note to the db. We can show a custom error message here. We can also use the error hook to get the error and show it in the UI. Here catching a 404 error to display a custom message with a link to the notes page. Using the href utility to get type safety again.

## Mutations: notes/new.tsx

LIVE CODE ADD ROUTE. Relative route. Lets move to the notes.new.tsx route module. Default export has a form, capital letter. This is similar to our example from the slides. React Router Form component will provide extra features on top of default form component, such as client side nav avoiding full page reload.

There is a method post on this, which will call the route for the route module with its action. Try the post, app error. LIVE CODE ERROR BOUNDARY. Catch the not implemented error and show a custom error message. Avoiding full app error.

LIVE CODE ACTION. The action validates using zod and returns errors if invalid inside a badRequest wrapper. Customizable. Then it redirects. Show console of network tab to show the post and get requests. GET data note.new. POST data note.new with location in the equest. New GET for revalidation. Again, server-side mutation that updates the database, but there is a client side equivalent clientAction if we were not working with the server side.

We don't need api routes to talk to our server from the client. Route module is it's own API route talking to itself. Using web standards like fetch and form submission.

## Revalidation: notes/new.tsx

Data is automatically revalidates. No fuss with adding items to lists. It's always the same. No manual revalidation. It's always in sync with the server. We can push or filter lists client side.

Show network tab loading and revalidating.

## RRM for single note: notes/detail.tsx

Lets move to a more complex route module with lots of features. LIVE CODE ADD ROUTE.

Go to detail.tsx. This is a dynamic route with params. Show config routes.ts for this. Show it in the app. It's a route module for a single note. It's using the loader to fetch the data for the note with the id from the database. It's using the loaderData prop to pass the data to the component, and throw a 404 if no note is found.

It's also using the useRouteError hook to catch any errors that might occur when fetching the data. It's using the error hook to get the error and show it in the UI and handle 404 errors differently.

NoteDisplay can delete a note, but this is now a relative URL using a action="/destroy". Using a form as well which is unfamiliar for React devs who usually just do button onClicks. This is a relative URL, resource route, that will call the route module with the action destroy. Defined with code based routing. It's using the action to delete the note from the database, and redirect. Web standard stuff that at least for me is very unfamiliar as a React SPA dev originally. Delete checks for the intent to be expected. This can be used to handle multiple actions in the same route module. Then deletes from the db and redirects.

It can also be favorited. Maybe a bit weird to see a form for this. This triggers the relative URL action="/". This is a relative URL that will call the route module with the action favorite. Here we use a fetcher Form because we are not navigating anywhere and we don't want to trigger a new push to the router.

## Browser framework

The app has some, realistic added delay and that makes it not feel so good. And until we didn't actually use that much of the browser framework, only Form and Links and prefetching etc. Does this feel like React? We are able to create all this without any React-stuff. Amazing right?

Thats all good, but for a good user experience we need to add some loading states and optimistic UI. We need to showcase whenever the user clicks by providing instant feedback. This is where the browser framework comes in. Let's start adding some UI enhancements using more of the browser framework of React Router.

### Loading UI: home.tsx

LIVE CODE: In the home.tsx, we will use a React Router specific hook called useNavigation. It will give you the current state of the navigation, and provide i.e whether the router is navigating, which we use here to mark the page as pending with css or text. This hook adds on top of our base case HTML web standard document with additional client-side, js enhanced features. This is React Router's way to do progressive enhancement.

### Loading UI: notes/sidebar.tsx

LIVE CODE: We will again use the useNavigation hook to show a loading state when navigating to the notes page, here with CSS and a pulsing animation.

However, to avoid running it during our creating of new note, we need to add a check for the pathname.

As someone coming from Next.js, this feels weird because you never get global behavior to like that unless you specifically create it yourself with a context.

We will also change to NavLink and use the prop callbacks from NavLink to render and style the link based on its state, here isPending and isActive. Again check the route. Browser framework is used to enhance the UI with loading states and active states.

### Pending UI + Optimistic UI: notes/detail.tsx

LIVE CODE: Delete is enhanced with a disabled button again when the navigation is not idle and is on the intent "delete".

For the favorite, we can get the state of this fetcher form locally and do another optimistic update. Fetcher is local scoped to the component.

### Optimistic UI: notes/new.tsx

LIVE CODE: It's doing optimistic UI by returning a view of a JokeDisplay if the validation succeeds. This is a client side update that will show the note in the list before the server has responded.

## Progressive enhancement turn off JS

Go to fullscreen app.

Turn off JS and see that the app still works. Web fundamentals in play to navigate, submit forms. Just lacking the client side enhancement of prefetching and client side navigation. And no client side loading state. And optimistic updates. Can even favorite because it's a form.

Can return errors from the form and delete notes. But we don't get client side pending state or optimistic updates. Thats all a progressive enhancement of this base case web standard application.

## Conclusion

We still didn't use any useState or useEffect here. But we can of course add it to our relevant components without any problem in the future. You know how to do that! React Router solves problems with RRM and additional hooks. Feels native to web. Can integrate any libs like normal for more react stuff. Add in React Query or any sort of client side stuff based on need.
